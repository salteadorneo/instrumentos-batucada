---
import type { CollectionEntry } from "astro:content";
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import FormattedDate from "../components/FormattedDate.astro";

type Props = CollectionEntry<"blog">["data"];

const { title, description, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="es">
	<head>
		<BaseHead title={title} description={description} />
	</head>

	<body>
		<Header />
		<main>
			<article class="container mx-auto">
				{
					heroImage && (
						<img width={720} height={360} src={heroImage} alt="" />
					)
				}
				<h1 class="text-2xl font-bold">{title}</h1>
				<FormattedDate date={pubDate} />
				{
					updatedDate && (
						<div class="last-updated-on">
							Last updated on <FormattedDate date={updatedDate} />
						</div>
					)
				}
				<hr />
				<slot />
			</article>
		</main>
		<Footer />
		<script type="module" is:inline>
			export async function getPageContent(url) {
				// This is a really scrappy way to do this.
				// Don't do this in production!
				const response = await fetch(url);
				const text = await response.text();
				// Particularly as it uses regexp
				return /<body[^>]*>([\w\W]*)<\/body>/.exec(text)[1];
			}

			function isBackNavigation(navigateEvent) {
				if (
					navigateEvent.navigationType === "push" ||
					navigateEvent.navigationType === "replace"
				) {
					return false;
				}
				if (
					navigateEvent.destination.index !== -1 &&
					navigateEvent.destination.index <
						navigation.currentEntry.index
				) {
					return true;
				}
				return false;
			}

			// Intercept navigations
			// https://developer.chrome.com/docs/web-platform/navigation-api/
			// This is a naive usage of the navigation API, to keep things simple.
			export async function onLinkNavigate(callback) {
				navigation.addEventListener("navigate", (event) => {
					const toUrl = new URL(event.destination.url);

					if (location.origin !== toUrl.origin) return;

					const fromPath = location.pathname;
					const isBack = isBackNavigation(event);

					event.intercept({
						async handler() {
							if (event.info === "ignore") return;

							await callback({
								toPath: toUrl.pathname,
								fromPath,
								isBack,
							});
						},
					});
				});
			}

			export function getLink(href) {
				const fullLink = new URL(href, location.href).href;

				return [...document.querySelectorAll("a")].find(
					(link) => link.href === fullLink
				);
			}

			// This helper function returns a View-Transition-like object, even for browsers that don't support view transitions.
			// It won't do the transition in unsupported browsers, it'll act as if the transition is skipped.
			// It also makes it easier to add class names to the document element.
			export function transitionHelper({
				skipTransition = false,
				classNames = "",
				updateDOM,
			}) {
				if (skipTransition || !document.startViewTransition) {
					const updateCallbackDone = Promise.resolve(
						updateDOM()
					).then(() => undefined);

					return {
						ready: Promise.reject(
							Error("View transitions unsupported")
						),
						domUpdated: updateCallbackDone,
						updateCallbackDone,
						finished: updateCallbackDone,
					};
				}

				const classNamesArray = classNames
					.split(/\s+/g)
					.filter(Boolean);

				document.documentElement.classList.add(...classNamesArray);

				const transition = document.startViewTransition(updateDOM);

				transition.finished.finally(() =>
					document.documentElement.classList.remove(
						...classNamesArray
					)
				);

				return transition;
			}

			onLinkNavigate(async ({ toPath }) => {
				const content = await getPageContent(toPath);
				startViewTransition(() => {
					document.body.innerHTML = content;
				});
			});

			function startViewTransition(callback) {
				if (!document.startViewTransition) {
					callback();
					return;
				}

				document.startViewTransition(callback);
			}
		</script>
	</body>
</html>
